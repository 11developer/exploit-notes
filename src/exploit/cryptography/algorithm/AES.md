---
title: AES (Advanced Encryption Standard)
description: AES is a specification for the encryption of electronic data.
tags:
    - Cryptography
refs:
	- https://www.javainuse.com/aesgenerator
    - https://zhangzeyu2001.medium.com/attacking-cbc-mode-bit-flipping-7e0a1c185511
date: 2023-07-28
draft: false
---

## Decrypt

### GPG

```bash
gpg --decrypt example.gpg
```

### OpenSSL

```bash
# AES-256-CBC
openssl aes-256-cbc -d -in encrypted_text -out decrypted.txt

# AES-256-CBC (PBKDF2)
openssl aes-256-cbc -pbkdf2 -iter 10000 -d -in encrypted_text -out decrypted.txt
```

<br />

## Encrypt

### GPG

```bash
gpg --symmetric --cipher-algo CIPHER message.txt
```

### OpenSSL

```bash
# AES-256-CBC
openssl aes-256-cbc -e -in message.txt -out encrypted_message

# AES-256-CBC (PBKDF2)
openssl aes-256-cbc -pbkdf2 -iter 10000 -e -in message.txt -out encrypted_message
```

### PowerShell

Reference: https://learn.microsoft.com/ja-jp/powershell/module/microsoft.powershell.security/convertto-securestring?view=powershell-7.3

```powershell
# Generate a secure string (input a plain text in prompt)
$secure = Read-Host -AsSecureString

# Store a key
$key = (1..16)

# Generate an encrypted string from the secure string
$encrypted = ConvertFrom-SecureString -SecureString $secure
# using key
$encrypted = ConvertFrom-SecureString -SecureString $secure -Key $key

echo $encrypted

# Convert an encrypted string to a secure string
$secure2 = ConvertTo-SecureString -String $encrypted
# using key
$secure2 = ConvertTo-SecureString -String $encrypted -Key $key

echo $secure2

# Reveal user password
$userpass = (New-Object pscredential 0, $encrypted).GetNetworkCredential().Password
```

<br />

## Implement AES in Python

Reference: [https://medium.com/quick-code/aes-implementation-in-python-a82f582f51c2](https://medium.com/quick-code/aes-implementation-in-python-a82f582f51c2)  

We need **`pycryptodome`** for implementing AES easily.

```bash
pip install pycryptodome
```

Below is a Python script for AES encryption and decryption.

```python
import hashlib
from Crypto import Random
from Crypto.Cipher import AES
from base64 import b64encode, b64decode

class AESCipher(object):
	def __init__(self, key):
		# AES block size is 128 bit
		self.block_size = AES.block_size
		# Generate unique 256 bit key
		self.key = hashlib.sha256(key.encode()).digest()

	def encrypt(self, plaintext):
		plaintext = self.__pad(plaintext)
		# IV (Initialization Vector) is the same size as the block size
		iv = Random.new().read(self.block_size)
		cipher = AES.new(self.key, AES.MODE_CBC, iv)
		ciphertext = cipher.encrypt(plaintext.encode())
		return b64encode(iv + ciphertext).decode('utf-8')

	def decrypt(self, ciphertext):
		ciphertext = b64decode(ciphertext)
		iv = ciphertext[:self.block_size]
		cipher = AES.new(self.key, AES.MODE_CBC, iv)
		plaintext = cipher.decrypt(ciphertext[self.block_size:]).decode('utf-8')
		return self.__unpad(plaintext)

	# Pad a plaintext for it to be a multiple of 128 bits.
	def __pad(self, plaintext):
		num_of_bytes_to_pad = self.block_size - len(plaintext) % self.block_size
		ascii_str = chr(num_of_bytes_pad)
		pad_str = num_of_bytes_to_pad * ascii_str
		pad_plaintext = plaintext + pad_str
		return pad_plaintext

	@staticmethod
	def __unpad(plaintext):
		last_char = plaintext[len(plaintext) -1:]
		bytes_to_remove = ord(last_char)
		return plaintext[:-bytes_to_remove]
```

<br />

## AES-CBC Bit Flipping Attack

For example from famous CTF solution, assume that a plaintext and ciphertext pair as follow.

```sh
# plaintext
logged_username=admin&parsword=aNth3m2023&password=g0ld3n_b0y

# ciphertext generated from the plaintext
f9d300b808e4c5ab535bc2c71600b58c328d2dc808ffa98740253a9f1fd905a05ddc53999f7f515427212aad1ea8831d2833732d29529899a0ec964c2f23fb58
```

Usually, CBC (Cipher Block Chaining) mode encrypts a plaintext every 16 bytes after XORing with the previous ciphertext. By the way, the first block of the plaintext is XORed with IV (initialization vector, generated random 16 bytes). Below depicts the process.

### Encryption Process

```sh
# Block 1
ENCRYPT(logged_username= XOR IV)
# ciphertext 1
f9d300b808e4c5ab535bc2c71600b58c

# Block 2
ENCRYPT(admin&parsword=a XOR f9d300b808e4c5ab535bc2c71600b58c)
# ciphertext 2
328d2dc808ffa98740253a9f1fd905a0

# Block 3
ENCRYPT(Nth3m2023&passwo XOR 328d2dc808ffa98740253a9f1fd905a0)
# ciphertext 3
5ddc53999f7f515427212aad1ea8831d

# Block 4
ENCRYPT(rd=g0ld3n_b0yxxx XOR 5ddc53999f7f515427212aad1ea8831d)
# ciphertext 4
2833732d29529899a0ec964c2f23fb58
```

### Decryption Process

We can reverse the above process as below. Decrypted ciphertext is XORed with the previous ciphertext every 16 bytes.

```python
# Block 1
DECRYPT(f9d300b808e4c5ab535bc2c71600b58c) XOR iv
# plaintext 1
logged_username=

# Block 2
DECRYPT(328d2dc808ffa98740253a9f1fd905a0) XOR f9d300b808e4c5ab535bc2c71600b58c
# plaintext 2
admin&parsword=a

# Block 3
DECRYPT(5ddc53999f7f515427212aad1ea8831d) XOR 328d2dc808ffa98740253a9f1fd905a
# plaintext 3
Nth3m2023&passw

# Block 4
DECRYPT(2833732d29529899a0ec964c2f23fb58) XOR 5ddc53999f7f515427212aad1ea8831d
# plaintext 4
rd=g0ld3n_b0yxxx
```

### Exploitation - CTF Solution

In terms of usual CTF solution, by changing the value at the position of ‘r’ in ‘parsword’ on the ciphertext to XORed value, we can get the original plaintext. It does not affect other blocks. Extracting that part:

```sh
# Block 2 (change 53 -> 52 at the 9th byte)
DECRYPT(328d2dc808ffa98740253a9f1fd905a0) XOR f9d300b808e4c5ab 52 5bc2c71600b58c
# plaintext 2 (changed 'r' to 's' at the 9th byte)
admin&password=a
```
